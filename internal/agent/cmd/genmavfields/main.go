package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path"
	"reflect"
	"sort"

	"github.com/bluenviron/gomavlib/v3/pkg/dialects/common"
)

var stringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()

type helperSpec struct {
	name     string
	elemKind reflect.Kind
}

var byteArrayEncodings = map[string]string{
	"MessageCameraInformation.ModelName":     "ascii",
	"MessageCameraInformation.VendorName":    "ascii",
	"MessageResourceRequest.Storage":         "ascii",
	"MessageResourceRequest.Uri":             "ascii",
	"MessageGpsStatus.SatelliteAzimuth":      "numeric",
	"MessageGpsStatus.SatelliteElevation":    "numeric",
	"MessageGpsStatus.SatellitePrn":          "numeric",
	"MessageGpsStatus.SatelliteSnr":          "numeric",
	"MessageGpsStatus.SatelliteUsed":         "numeric",
	"MessageOnboardComputerStatus.CpuCombined": "numeric",
	"MessageOnboardComputerStatus.CpuCores":    "numeric",
	"MessageOnboardComputerStatus.GpuCombined": "numeric",
	"MessageOnboardComputerStatus.GpuCores":    "numeric",
}

func main() {
	outPath := flag.String("o", "mav_fields_gen.go", "output file")
	flag.Parse()

	msgTypes := collectMessageTypes()
	imports, helpers := collectImportsAndHelpers(msgTypes)

	var buf bytes.Buffer
	buf.WriteString("// Code generated by genmavfields. DO NOT EDIT.\n")
	buf.WriteString("package agent\n\n")

	writeImports(&buf, imports)
	writeHelpers(&buf, helpers)
	writeMapper(&buf, msgTypes, helpers)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to format generated code: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(*outPath, formatted, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write generated code: %v\n", err)
		os.Exit(1)
	}
}

func collectMessageTypes() []reflect.Type {
	seen := make(map[string]reflect.Type)
	for _, msg := range common.Dialect.Messages {
		t := reflect.TypeOf(msg)
		if t == nil || t.Kind() != reflect.Ptr {
			continue
		}
		elem := t.Elem()
		if elem.Kind() != reflect.Struct {
			continue
		}
		seen[t.String()] = t
	}

	types := make([]reflect.Type, 0, len(seen))
	for _, t := range seen {
		types = append(types, t)
	}
	sort.Slice(types, func(i, j int) bool {
		return types[i].String() < types[j].String()
	})
	return types
}

func collectImportsAndHelpers(msgTypes []reflect.Type) (map[string]string, []helperSpec) {
	imports := map[string]string{
		"fmt":                                        "fmt",
		"github.com/bluenviron/gomavlib/v3/pkg/message": "message",
		"strconv":                                   "strconv",
		"strings":                                   "strings",
	}

	helperSet := make(map[helperSpec]struct{})

	for _, t := range msgTypes {
		elem := t.Elem()
		if pkg := elem.PkgPath(); pkg != "" {
			imports[pkg] = path.Base(pkg)
		}

		for i := 0; i < elem.NumField(); i++ {
			field := elem.Field(i)
			if field.PkgPath != "" {
				continue
			}
			if field.Type.Kind() != reflect.Array {
				continue
			}
			elemKind := field.Type.Elem().Kind()
			if elemKind == reflect.Uint8 {
				continue
			}
			helper, ok := helperForKind(elemKind)
			if !ok {
				continue
			}
			helperSet[helper] = struct{}{}
		}
	}

	helpers := make([]helperSpec, 0, len(helperSet))
	for helper := range helperSet {
		helpers = append(helpers, helper)
	}
	sort.Slice(helpers, func(i, j int) bool {
		return helpers[i].name < helpers[j].name
	})

	return imports, helpers
}

func helperForKind(kind reflect.Kind) (helperSpec, bool) {
	switch kind {
	case reflect.Float32:
		return helperSpec{name: "formatFloat32Array", elemKind: reflect.Float32}, true
	case reflect.Float64:
		return helperSpec{name: "formatFloat64Array", elemKind: reflect.Float64}, true
	case reflect.Int8:
		return helperSpec{name: "formatInt8Array", elemKind: reflect.Int8}, true
	case reflect.Int16:
		return helperSpec{name: "formatInt16Array", elemKind: reflect.Int16}, true
	case reflect.Int32:
		return helperSpec{name: "formatInt32Array", elemKind: reflect.Int32}, true
	case reflect.Int64:
		return helperSpec{name: "formatInt64Array", elemKind: reflect.Int64}, true
	case reflect.Uint16:
		return helperSpec{name: "formatUint16Array", elemKind: reflect.Uint16}, true
	case reflect.Uint32:
		return helperSpec{name: "formatUint32Array", elemKind: reflect.Uint32}, true
	case reflect.Uint64:
		return helperSpec{name: "formatUint64Array", elemKind: reflect.Uint64}, true
	default:
		return helperSpec{}, false
	}
}

func writeImports(buf *bytes.Buffer, imports map[string]string) {
	keys := make([]string, 0, len(imports))
	for path := range imports {
		keys = append(keys, path)
	}
	sort.Strings(keys)

	buf.WriteString("import (\n")
	for _, path := range keys {
		alias := imports[path]
		if alias == "" || alias == path {
			fmt.Fprintf(buf, "\t%q\n", path)
			continue
		}
		fmt.Fprintf(buf, "\t%s %q\n", alias, path)
	}
	buf.WriteString(")\n\n")
}

func writeHelpers(buf *bytes.Buffer, helpers []helperSpec) {
	writeStringerHelper(buf)
	writeByteHelpers(buf)
	if len(helpers) == 0 {
		return
	}

	for _, helper := range helpers {
		writeHelper(buf, helper)
	}
}

func writeStringerHelper(buf *bytes.Buffer) {
	buf.WriteString("func formatStringerArray[T fmt.Stringer](values []T) string {\n")
	buf.WriteString("\tif len(values) == 0 {\n")
	buf.WriteString("\t\treturn \"[]\"\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tvar b strings.Builder\n")
	buf.WriteString("\tb.Grow(len(values) * 6)\n")
	buf.WriteString("\tb.WriteByte('[')\n")
	buf.WriteString("\tfor i, v := range values {\n")
	buf.WriteString("\t\tif i > 0 {\n")
	buf.WriteString("\t\t\tb.WriteByte(',')\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tb.WriteString(v.String())\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tb.WriteByte(']')\n")
	buf.WriteString("\treturn b.String()\n")
	buf.WriteString("}\n\n")
}

func writeByteHelpers(buf *bytes.Buffer) {
	buf.WriteString("func formatASCII(values []uint8) string {\n")
	buf.WriteString("\tif len(values) == 0 {\n")
	buf.WriteString("\t\treturn \"\"\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tend := len(values)\n")
	buf.WriteString("\tfor i, v := range values {\n")
	buf.WriteString("\t\tif v == 0 {\n")
	buf.WriteString("\t\t\tend = i\n")
	buf.WriteString("\t\t\tbreak\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn string(values[:end])\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func formatUint8Array(values []uint8) string {\n")
	buf.WriteString("\tif len(values) == 0 {\n")
	buf.WriteString("\t\treturn \"[]\"\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tvar b strings.Builder\n")
	buf.WriteString("\tb.Grow(len(values) * 4)\n")
	buf.WriteString("\tb.WriteByte('[')\n")
	buf.WriteString("\tfor i, v := range values {\n")
	buf.WriteString("\t\tif i > 0 {\n")
	buf.WriteString("\t\t\tb.WriteByte(',')\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tb.WriteString(strconv.FormatUint(uint64(v), 10))\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tb.WriteByte(']')\n")
	buf.WriteString("\treturn b.String()\n")
	buf.WriteString("}\n\n")
}

func writeHelper(buf *bytes.Buffer, helper helperSpec) {
	fmt.Fprintf(buf, "func %s(values []%s) string {\n", helper.name, kindName(helper.elemKind))
	buf.WriteString("\tif len(values) == 0 {\n")
	buf.WriteString("\t\treturn \"[]\"\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tvar b strings.Builder\n")
	buf.WriteString("\tb.Grow(len(values) * 6)\n")
	buf.WriteString("\tb.WriteByte('[')\n")
	buf.WriteString("\tfor i, v := range values {\n")
	buf.WriteString("\t\tif i > 0 {\n")
	buf.WriteString("\t\t\tb.WriteByte(',')\n")
	buf.WriteString("\t\t}\n")

	switch helper.elemKind {
	case reflect.Float32:
		buf.WriteString("\t\tb.WriteString(strconv.FormatFloat(float64(v), 'f', -1, 32))\n")
	case reflect.Float64:
		buf.WriteString("\t\tb.WriteString(strconv.FormatFloat(float64(v), 'f', -1, 64))\n")
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		buf.WriteString("\t\tb.WriteString(strconv.FormatInt(int64(v), 10))\n")
	case reflect.Uint16, reflect.Uint32, reflect.Uint64:
		buf.WriteString("\t\tb.WriteString(strconv.FormatUint(uint64(v), 10))\n")
	default:
		buf.WriteString("\t\tb.WriteString(strconv.FormatInt(int64(v), 10))\n")
	}

	buf.WriteString("\t}\n")
	buf.WriteString("\tb.WriteByte(']')\n")
	buf.WriteString("\treturn b.String()\n")
	buf.WriteString("}\n\n")
}

func writeMapper(buf *bytes.Buffer, msgTypes []reflect.Type, helpers []helperSpec) {
	buf.WriteString("// TODO: Decide how to encode MAVLink byte arrays; [N]uint8 fields are currently omitted.\n")
	buf.WriteString("func commonFields(msg message.Message) (map[string]string, bool) {\n")
	buf.WriteString("\tswitch m := msg.(type) {\n")

	for _, t := range msgTypes {
		elem := t.Elem()
		fmt.Fprintf(buf, "\tcase *%s.%s:\n", path.Base(elem.PkgPath()), elem.Name())
		fieldCount, fieldLines := buildFieldLines("m", elem)
		fmt.Fprintf(buf, "\t\tfields := make(map[string]string, %d)\n", fieldCount)
		for _, line := range fieldLines {
			buf.WriteString(line)
		}
		buf.WriteString("\t\treturn fields, true\n")
	}

	buf.WriteString("\tdefault:\n")
	buf.WriteString("\t\treturn nil, false\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n")
}

func buildFieldLines(varName string, t reflect.Type) (int, []string) {
	lines := []string{}
	fieldCount := 0
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.PkgPath != "" {
			continue
		}
		expr, ok := fieldExpression(varName, t, field)
		if !ok {
			continue
		}
		fieldCount++
		lines = append(lines, fmt.Sprintf("\t\tfields[%q] = %s\n", field.Name, expr))
	}
	return fieldCount, lines
}

func fieldExpression(varName string, t reflect.Type, field reflect.StructField) (string, bool) {
	fieldExpr := varName + "." + field.Name
	if field.Type.Implements(stringerType) {
		return fieldExpr + ".String()", true
	}

	switch field.Type.Kind() {
	case reflect.String:
		return fieldExpr, true
	case reflect.Bool:
		return "strconv.FormatBool(" + fieldExpr + ")", true
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return "strconv.FormatInt(int64(" + fieldExpr + "), 10)", true
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return "strconv.FormatUint(uint64(" + fieldExpr + "), 10)", true
	case reflect.Float32:
		return "strconv.FormatFloat(float64(" + fieldExpr + "), 'f', -1, 32)", true
	case reflect.Float64:
		return "strconv.FormatFloat(float64(" + fieldExpr + "), 'f', -1, 64)", true
	case reflect.Array:
		elemKind := field.Type.Elem().Kind()
		if field.Type.Elem().Implements(stringerType) {
			return "formatStringerArray(" + fieldExpr + "[:])", true
		}
		if elemKind == reflect.Uint8 {
			switch byteArrayEncodings[t.Name()+"."+field.Name] {
			case "ascii":
				return "formatASCII(" + fieldExpr + "[:])", true
			case "numeric":
				return "formatUint8Array(" + fieldExpr + "[:])", true
			default:
				return "", false
			}
		}
		helper, ok := helperForKind(elemKind)
		if !ok {
			return "", false
		}
		return helper.name + "(" + fieldExpr + "[:])", true
	default:
		return "", false
	}
}

func kindName(kind reflect.Kind) string {
	switch kind {
	case reflect.Float32:
		return "float32"
	case reflect.Float64:
		return "float64"
	case reflect.Int8:
		return "int8"
	case reflect.Int16:
		return "int16"
	case reflect.Int32:
		return "int32"
	case reflect.Int64:
		return "int64"
	case reflect.Uint16:
		return "uint16"
	case reflect.Uint32:
		return "uint32"
	case reflect.Uint64:
		return "uint64"
	default:
		return "int64"
	}
}
